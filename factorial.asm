;FACTORIAL 1~19
;ZJR 11.28
INCLUDE EMU8086.INC
.MODEL SMALL
.STACK 1024

.DATA
	ARRAY DB 20 DUP(0)
	RESULT DB 20 DUP(0)
	N DB 19
    BITNUM DW 1
    TEN DB 10
    
.CODE
FACT: 
    LEA DI,N
    MOV AL,19
    MOV [DI],AL
    LEA DI,BITNUM
    MOV AX,1
    MOV [DI],AX
    LEA DI,TEN
    MOV AL,10
    MOV [DI],AL  
      
    LEA DI,ARRAY
    MOV [DI],1      ;ARRAY[0]=1 
    XOR CX,CX
    MOV CL,N
    JMP FLOOP

;OUTER LOOP CX:N~1
FLOOP:
    CMP CX,10
    JGE GTTEN       ;IF CX>10 --> TWO PLACES
    ;ELSE --> ONE PLACE
    MOV DH,CL        ;ARGUMENT FOR ONEPLACE()
    CALL ONEPLACE
    CALL MEMCPY     ;COPY RESULT TO ARRAY
    CALL MEMCLEAR   ;SET RESULT TO BE CLEAR  
    
    DEC CX
    CMP  CX,0
    JNZ FLOOP
    JMP PRINT       ;LOOP END
    
;GREATER THAN 10:TWO PLACES
GTTEN:
    MOV AX,CX
    SUB AX,10       ;AX=CX%10=CX-10
    MOV DH,AL        ;ARGUMENT FOR ONEPLACE()
    CALL ONEPLACE   ;HANDLE ONE PLACE
    CALL TENPLACE   ;HANDLE TEN PLACE
    CALL MEMCPY     ;COPY RESULT TO ARRAY
    CALL MEMCLEAR   ;SET RESULT TO BE CLEAR 
    DEC CX
    CMP  CX,0
    JNZ FLOOP
    JMP PRINT       ;LOOP END

;RESULT+=ARRAY*10
TENPLACE:
    MOV BX,0
    LEA DI,ARRAY
    LEA SI,RESULT
    CALL TLOOP
    CALL CARRY
    RET

TLOOP:
    MOV DL,PTR DI+BX    ;DL=ARRAY[I]
    ADD DL,PTR SI+BX+1  ;DL=ARRAY[I]+RESULT[I+1]
    MOV PTR SI+BX+1,DL  ;RESULT[I+1]=DL
    INC BX
    CMP BX,BITNUM
    JNZ TLOOP
    RET
    
;RESULT+=ARRAY*AX
ONEPLACE: 
    MOV BX,0
    LEA DI,ARRAY
    LEA SI,RESULT
    CALL OLOOP
    CALL CARRY
    RET
    
OLOOP:
    MOV DL,PTR DI+BX    ;DL=ARRAY[BX]
    MOV AL,DH
    MUL DL              ;ARRAY[BX]*K->AX
    MOV PTR SI+BX,AL    ;AX->RESULT[BX]
    INC BX
    CMP BX,BITNUM
    JNZ OLOOP
    RET

;½øÎ»
CARRY:
    LEA SI,RESULT
    MOV BX,0
    CALL CLOOP
    MOV BX,BITNUM
    MOV AL,PTR SI+BX       ;RESULT[BITNUM]->AL
    CMP AL,0               ;IF RESULT[BITNUM]!=0
    JNZ NUMCARRAY
    RET

CLOOP:
    MOV DL,PTR SI+BX        ;RESULT[BX]->DL
    CMP DL,10               
    JGE CARRY1              ;IF (RESULT[BX]>10)->HANDLE IT
    INC BX                  ;++BX
    CMP BX,BITNUM
    JLE CLOOP
    RET

CARRY1:
    MOV AL,PTR SI+BX        ;RESULT[BX]->AL
    DIV TEN                 ;RESULT[BX]/10->AX
    ADD PTR SI+BX+1,AL      ;RESULT[BX+1]+=RESULT[BX]/10
    MUL TEN                 
    SUB PTR SI+BX,AL        ;RESULT[BX]=RESULT[BX]%10
    INC BX
    CMP BX,BITNUM
    JLE CLOOP
    RET       
    
NUMCARRAY:
    MOV AX,BITNUM
    ADD AX,1
    MOV BITNUM,AX
    RET
                
;COPY RESULT TO ARRAY
MEMCPY:
    MOV BX,0
    CALL MCPYLOOP
    RET

MCPYLOOP:
    MOV AL,PTR SI+BX       ;RESULT[BX]->AL
    MOV PTR DI+BX,AL       ;AL->ARRAY[BX]
    INC BX
    CMP BX,20
    JNZ MCPYLOOP
    RET 
    
;SET RESULT TO BE CLEAR
MEMCLEAR:
    MOV BX,0
    CALL MCLRLOOP
    RET

MCLRLOOP:
    MOV AL,0
    MOV PTR SI+BX,AL         ;RESULT[BX]=0
    INC BX
    CMP BX,20
    JNZ MCLRLOOP
    RET
         
;PRINT RESULT
PRINT:
    MOV CX,BITNUM
    DEC CX
    LEA DI,ARRAY
    JMP PLOOP
    
PLOOP:
    MOV BX,CX
    MOV AL,PTR DI+BX
    CALL PRINT_NUM
    DEC CX
    CMP CX,0
    JGE PLOOP  
    JMP  LEAVE

;END OF PROGRAM    
LEAVE:
    MOV AH,4CH
    INT 21H
    DEFINE_PRINT_NUM_UNS
    DEFINE_PRINT_NUM    
        